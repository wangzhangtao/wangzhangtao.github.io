<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>05-09.容器技术概念入门篇 | 蚂蚁博客</title><meta name="description" content="深入剖析Kubernetes - 05  05|白话容器基础（一）：从进程说开去容器是一种沙盒，容器技术的核心功能，就是通过约束和修改进程的动态表现，为应用与应用之间创造出“边界”。 对于 Docker 等 Linux 容器来说，Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法。 Namespace 其实只是 Linux 创建新进程的一个"><meta name="keywords" content="kubernetes,深入剖析Kuernetes"><meta name="author" content="会跳的小蚂蚁"><meta name="copyright" content="会跳的小蚂蚁"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="05-09.容器技术概念入门篇"><meta name="twitter:description" content="深入剖析Kubernetes - 05  05|白话容器基础（一）：从进程说开去容器是一种沙盒，容器技术的核心功能，就是通过约束和修改进程的动态表现，为应用与应用之间创造出“边界”。 对于 Docker 等 Linux 容器来说，Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法。 Namespace 其实只是 Linux 创建新进程的一个"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="05-09.容器技术概念入门篇"><meta property="og:url" content="http://wang.ikongjian.com/2020/09/06/05-09-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8%E7%AF%87/"><meta property="og:site_name" content="蚂蚁博客"><meta property="og:description" content="深入剖析Kubernetes - 05  05|白话容器基础（一）：从进程说开去容器是一种沙盒，容器技术的核心功能，就是通过约束和修改进程的动态表现，为应用与应用之间创造出“边界”。 对于 Docker 等 Linux 容器来说，Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法。 Namespace 其实只是 Linux 创建新进程的一个"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="article:published_time" content="2020-09-06T02:00:00.000Z"><meta property="article:modified_time" content="2020-10-18T10:19:30.358Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://wang.ikongjian.com/2020/09/06/05-09-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8%E7%AF%87/"><link rel="prev" title="nacos的部署和使用" href="http://wang.ikongjian.com/2020/09/07/nacos%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8/"><link rel="next" title="00-04.深入剖析k8s课前必读" href="http://wang.ikongjian.com/2020/09/01/00-04-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90k8s%E8%AF%BE%E5%89%8D%E5%BF%85%E8%AF%BB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">91</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">48</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">40</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/2020/07/01/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#05-白话容器基础（一）：从进程说开去"><span class="toc-number">1.</span> <span class="toc-text">05|白话容器基础（一）：从进程说开去</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机和容器"><span class="toc-number">1.1.</span> <span class="toc-text">虚拟机和容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06-白话容器基础（二）：隔离和限制"><span class="toc-number">2.</span> <span class="toc-text">06|白话容器基础（二）：隔离和限制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#隔离得不彻底"><span class="toc-number">2.1.</span> <span class="toc-text">隔离得不彻底</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器的“限制”问题。"><span class="toc-number">2.2.</span> <span class="toc-text">容器的“限制”问题。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用cfs-period-和-cfs-quota控制CPU"><span class="toc-number">2.3.</span> <span class="toc-text">利用cfs_period 和 cfs_quota控制CPU</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07-白话容器基础（三）：深入理解容器镜像"><span class="toc-number">3.</span> <span class="toc-text">07 | 白话容器基础（三）：深入理解容器镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器镜像的分层"><span class="toc-number">3.1.</span> <span class="toc-text">容器镜像的分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写时复制"><span class="toc-number">3.2.</span> <span class="toc-text">写时复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小知识点"><span class="toc-number">3.3.</span> <span class="toc-text">小知识点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#知识扩展"><span class="toc-number">3.4.</span> <span class="toc-text">知识扩展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08-白话容器基础（四）：重新认识Docker容器"><span class="toc-number">4.</span> <span class="toc-text">08 | 白话容器基础（四）：重新认识Docker容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Volume挂载"><span class="toc-number">4.1.</span> <span class="toc-text">Volume挂载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本章的主要问题（没答案）"><span class="toc-number">4.2.</span> <span class="toc-text">本章的主要问题（没答案）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-Namespace-工作原理"><span class="toc-number">4.3.</span> <span class="toc-text">Linux Namespace 工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09-从容器到容器云：谈谈Kubernetes的本质"><span class="toc-number">5.</span> <span class="toc-text">09 | 从容器到容器云：谈谈Kubernetes的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器概述"><span class="toc-number">5.1.</span> <span class="toc-text">容器概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes架构"><span class="toc-number">5.2.</span> <span class="toc-text">Kubernetes架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubernetes设计思想"><span class="toc-number">5.3.</span> <span class="toc-text">Kubernetes设计思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何容器化应用"><span class="toc-number">5.4.</span> <span class="toc-text">如何容器化应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编排和调度区别"><span class="toc-number">5.5.</span> <span class="toc-text">编排和调度区别</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">蚂蚁博客</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/2020/07/01/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">05-09.容器技术概念入门篇</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-06 10:00:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-09-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-10-18 18:19:30"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-10-18</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kubernetes/">kubernetes</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/kubernetes/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/">深入剖析Kubernetes</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.9k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 20 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><blockquote>
<p> <a href="https://time.geekbang.org/column/article/14642" target="_blank" rel="noopener">深入剖析Kubernetes - 05</a></p>
</blockquote>
<h1 id="05-白话容器基础（一）：从进程说开去"><a href="#05-白话容器基础（一）：从进程说开去" class="headerlink" title="05|白话容器基础（一）：从进程说开去"></a>05|白话容器基础（一）：从进程说开去</h1><p>容器是一种沙盒，容器技术的核心功能，就是通过约束和修改进程的动态表现，为应用与应用之间创造出“边界”。</p>
<p>对于 Docker 等 Linux 容器来说，Cgroups 技术是用来制造约束的主要手段，而 Namespace 技术则是用来修改进程视图的主要方法。</p>
<p>Namespace 其实只是 Linux 创建新进程的一个可选参数。</p>
<p>Linux 操作系统提供了 PID（） ， Mount（文件系统）、UTS（时间）、IPC(进程间通信)、Network （网络）和 User （用户）这些 Namespace</p>
<p>进程包括计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合，是运行起来后的计算机执行环境的总和，</p>
<p>进程是动态的程序，程序是静态的进程</p>
<p>容器是一个单进程。单进程意思不是只能运行一个进程，而是只有一个进程是可控的；控制指的是它们的回收和生命周期管理。</p>
<h2 id="虚拟机和容器"><a href="#虚拟机和容器" class="headerlink" title="虚拟机和容器"></a>虚拟机和容器</h2><img src="/img/body/jike/docker-hypervisor.png" alt="虚拟机和容器对比图" style="zoom:50%;max-width:60%" />

<p>Hypervisor 是虚拟机通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件，比如 CPU、内存、I/O 设备等等。然后，它在这些虚拟的硬件上安装了一个新的操作系统，即 Guest OS，但它带来了额外的资源消耗和占用。</p>
<p>使用 Docker 的时候，并没有一个真正的“Docker 容器”运行在宿主机里面。Docker 项目帮助用户启动的应用进程，只不过是在创建这些进程时， 为它们加上了各种各样的 Namespace 参数，真实进程是直接run在host os上。</p>
<p>“敏捷”和“高性能”是容器相较于虚拟机最大的优势，也是它能够在 PaaS 这种更细粒度的资源管理平台上大行其道的重要原因。</p>
<h1 id="06-白话容器基础（二）：隔离和限制"><a href="#06-白话容器基础（二）：隔离和限制" class="headerlink" title="06|白话容器基础（二）：隔离和限制"></a>06|白话容器基础（二）：隔离和限制</h1><p>容器是一个“单进程”模型，这是因为容器本身的设计，就是希望容器和应用能够同生命周期，方便对进程进行控制。</p>
<p>容器的资源隔离（进程视图）是通过linux  namespace实现（进程启动时指定namespace参数），容器的资源限制（cpu，memory大小等）是通过linux  cgroups实现（通过修改/proc目录下对应容器的文件信息）</p>
<p>容器的隔离只是相对于容器进程本身做了隔离，宿主机操作系统还是可以看到对应容器进程的真实的进程信息。容器的本质是一种特殊的进程，这些被“隔离”了的进程跟其他进程并没有太大区别。</p>
<p>相较于虚拟机，容器通过共享宿主机的os内核从而更加的轻量级化，性能更高，但同时也使容器的隔离变的不彻底。同时，对于系统时间是不可以通过namespace进行隔离的。</p>
<h2 id="隔离得不彻底"><a href="#隔离得不彻底" class="headerlink" title="隔离得不彻底"></a>隔离得不彻底</h2><p>首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。</p>
<p>其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。</p>
<p>top 指令查看系统信息的主要数据来源是/proc目录，  /proc 目录存储的是记录当前内核运行状态的一系列特殊文件</p>
<h2 id="容器的“限制”问题。"><a href="#容器的“限制”问题。" class="headerlink" title="容器的“限制”问题。"></a>容器的“限制”问题。</h2><p>Linux Cgroups 的全称是 Linux Control Group。</p>
<p>Linux Cgroups 是 Linux 内核中用来为进程设置资源限制的，限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。</p>
<p>Linux Cgroups 的设计就是一个子系统目录加上一组资源限制文件的组合。</p>
<p>Cgroups  的每一个子系统都有其独有的资源限制能力，比如：</p>
<ul>
<li><p>cpu, 为进程分配cpu资源</p>
</li>
<li><p>blkio，为块设备设定I/O  限制，一般用于磁盘等设备；</p>
</li>
<li><p>cpuset，为进程分配单独的 CPU 核和对应的内存节点；</p>
</li>
<li><p>memory，为进程设定内存使用的限制。</p>
</li>
</ul>
<p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。用mount -t cgroup 指令把它们展示出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mount -t cgroup </span><br><span class="line">cpuset on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cpu on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu type cgroup (rw,nosuid,nodev,noexec,relatime,cpu)</span><br><span class="line">cpuacct on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)</span><br><span class="line">blkio on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">memory on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>在 /sys/fs/cgroup 下面有很多 cpuset、cpu、 memory 等目录，而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu</span><br><span class="line">cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release</span><br><span class="line">cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks</span><br></pre></td></tr></table></figure>



<h2 id="利用cfs-period-和-cfs-quota控制CPU"><a href="#利用cfs-period-和-cfs-quota控制CPU" class="headerlink" title="利用cfs_period 和 cfs_quota控制CPU"></a>利用cfs_period 和 cfs_quota控制CPU</h2><p>cfs_period 和 cfs_quota组合使用，可以用来限制进程在长度为 cfs_period 的一段时间内，只能被分配到总量为 cfs_quota 的 CPU 时间。</p>
<p>在对应的子系统下面创建一个目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@ubuntu:&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu$ mkdir container</span><br><span class="line">root@ubuntu:&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu$ ls container&#x2F;</span><br><span class="line">cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us  cpu.shares notify_on_release</span><br><span class="line">cgroup.procs      cpu.cfs_quota_us  cpu.rt_runtime_us cpu.stat  tasks</span><br></pre></td></tr></table></figure>

<p>操作系统会在你新创建的 container 目录下，自动生成该子系统对应的资源限制文件。</p>
<p>执行一个进程，它是一个死循环，可以把计算机的 CPU 吃到 100%，根据它的输出，我们可以看到这个脚本在后台运行的进程号（PID）是 226。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ while : ; do : ; done &amp;</span><br><span class="line">[1] 226</span><br></pre></td></tr></table></figure>

<p>我们可以用top确认CPU利用率</p>
<p>我们查看 container 目录下的文件，看到 container 控制组里的 CPU quota 还没有任何限制（即：-1），CPU period 则是默认的 100  ms（100000  us）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_quota_us </span><br><span class="line">-1</span><br><span class="line">$ cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_period_us </span><br><span class="line">100000</span><br></pre></td></tr></table></figure>



<p>通过修改这些文件的内容来设置限制。比如，向 container 组里的 cfs_quota 文件写入 20  ms（20000  us）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 20000 &gt; &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>

<p>我们把被限制的进程的 PID 写入 container 组里的 tasks 文件，上面的设置就会对该进程生效了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo 226 &gt; &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;tasks</span><br></pre></td></tr></table></figure>

<p> top 指令查看查看结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ top</span><br><span class="line">%Cpu0 : 20.3 us, 0.0 sy, 0.0 ni, 79.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st</span><br></pre></td></tr></table></figure>





<h1 id="07-白话容器基础（三）：深入理解容器镜像"><a href="#07-白话容器基础（三）：深入理解容器镜像" class="headerlink" title="07 | 白话容器基础（三）：深入理解容器镜像"></a>07 | 白话容器基础（三）：深入理解容器镜像</h1><p>容器里的进程看到的文件系统是，Mount Namespace 修改的，容器进程对文件系统“挂载点”的认知。</p>
<p>Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。</p>
<p>在 Linux 操作系统里，有一个名为 chroot（change root file system） 的命令可以改变进程的根目录到你指定的位置。</p>
<p>Mount Namespace 正是基于对 chroot 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace。</p>
<p>挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”; 它的本质就是容器的根文件系统(rootfs)。</p>
<p>对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：</p>
<ol>
<li><p>启用 Linux Namespace 配置 : 视图隔离；</p>
</li>
<li><p>设置指定的 Cgroups 参数 : 资源限制 ;</p>
</li>
<li><p>切换进程的根目录（Change Root）;容器镜像生效，以实现环境一致性。</p>
</li>
</ol>
<p>rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</p>
<p>由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，所以应用以及它运行所需要的所有依赖，都被封装在了一起。所以容器才有了一个重要特性：一致性。</p>
<p>对一个应用来说，操作系统本身才是它运行所需要的最完整的“依赖库”。</p>
<h2 id="容器镜像的分层"><a href="#容器镜像的分层" class="headerlink" title="容器镜像的分层"></a>容器镜像的分层</h2><p>Docker 在镜像的设计中，引入了层（layer）的概念。用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p>
<p>UnionFS（Union File System）最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。</p>
<p>现在docker默认用 overlay2 作为 storage driver 主要是性能更好。而且 OverlayFS 已经进入 Linux 内核主线，而 AUFS 被拒。</p>
<p>“镜像”的三层：第一部分，只读层；第二部分，可读写层；第三部分，Init 层。</p>
<p>Init 层是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等初始化时产生的信息。用户执行 docker commit 只会提交可读写层，不包含init层</p>
<h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><p>Copy-On-Write机制简称COW，是程序开发中比较常用的一种优化策略。在复制一个对象时,并不是真正的把原先的对象复制到内存的另外一个位置上，而是在新对象的内存映射表中设置一个指针，指向源对象的位置，并把那块内存的Copy-On-Write位设置为1，这是一种延时懒惰策略。<br>对于容器，我们从宿主机单独挂载了一个文件到容器里，然后修改宿主机的文件，容器里的文件却没生效。原因是，编辑过程中将变更写入新文件， 保存时再将备份文件替换原文件，此时会导致文件的inode发生变化。而docker  挂载文件时，并不是挂载了某个文件的路径，而是实打实的挂载了对应的文件，即<strong>挂载了inode文件</strong>。</p>
<h2 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h2><p>overlay共享数据方式是通过硬连接，而overlay2是通过每层的 lower文件。</p>
<p>katacontainers 基于虚拟化的容器是有独立内核的。</p>
<p>scratch 是万能的基础镜像。</p>
<p>kubernetes打开GC功能会定时清理镜像（默认开启）。</p>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ol>
<li><p>linux系统启动过程详解-开机加电后发生了什么 –linux内核剖析（零） <a href="https://blog.csdn.net/gatieme/article/details/50914250" target="_blank" rel="noopener">https://blog.csdn.net/gatieme/article/details/50914250</a></p>
</li>
<li><p>左耳朵耗子大师的 DOCKER基础技术：LINUX NAMESPACE 上下两篇，再去看官档关于overlay2的运行原理，还有linux mount技术的相关文章   <a href="https://coolshell.cn/articles/17010.html" target="_blank" rel="noopener">https://coolshell.cn/articles/17010.html</a></p>
</li>
</ol>
<h1 id="08-白话容器基础（四）：重新认识Docker容器"><a href="#08-白话容器基础（四）：重新认识Docker容器" class="headerlink" title="08 | 白话容器基础（四）：重新认识Docker容器"></a>08 | 白话容器基础（四）：重新认识Docker容器</h1><p>因为其他地方关于docker的基础命令和dockerfile参数已经很详细，这里我就不做过多记录。</p>
<p>Dockerfile 的设计思想，是使用一些标准的原语，描述我们所要构建的 Docker 镜像。并且这些原语，都是按顺序处理的。</p>
<p>Dockerfile 中的每个原语执行后，都会生成一个对应的镜像层。即使原语本身并没有明显地修改文件的操作（比如，ENV 原语），它对应的层也会存在。只不过在外界看来，这个层是空的。</p>
<p>docker commit，实际上就是在容器运行起来后，把最上层的“可读写层”，加上原先容器镜像的只读层，打包组成了一个新的镜像。当然下面这些只读层在宿主机上是共享的，不会占用额外的空间。</p>
<h2 id="Volume挂载"><a href="#Volume挂载" class="headerlink" title="Volume挂载"></a>Volume挂载</h2><p>Volume挂载时机:  在 rootfs 准备好之后，在执行 chroot 之前，把 Volume 指定的宿主机目录（比如 /home 目录），挂载到指定的容器目录（比如 /test 目录）在宿主机上对应的目录（即 /var/lib/docker/aufs/mnt/[可读写层 ID]/test）上，这个 Volume 的挂载工作就完成了</p>
<p>执行这个挂载操作时，“容器进程”已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见容器内部的这个挂载点的。这就保证了容器的隔离性不会被 Volume 打破。</p>
<p>注意：这里提到的”容器进程”，是 Docker 创建的一个容器初始化进程 (dockerinit)，而不是应用进程 (ENTRYPOINT + CMD)。dockerinit 会负责完成根目录的准备、挂载设备和目录、配置 hostname 等一系列需要在容器内进行的初始化操作。最后，它通过 execv() 系统调用，让应用进程取代自己，成为容器里的 PID=1 的进程。注意，容器里的其他进程都是1号进程的子进程，</p>
<p> Linux 的绑定挂载（bind mount）机制。它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。</p>
<p>Linux 绑定挂载实际上是一个 inode 替换的过程。在 Linux 操作系统中，inode 可以理解为存放文件内容的“对象”，而 dentry，也叫目录项，就是访问这个 inode 所使用的“指针”。</p>
<img src="/img/body/jike/95c957b3c2813bb70eb784b8d1daedc6-20200905173354769.png" alt="img" style="zoom:67%;max-width:60%" />



<p>所以，进行一次绑定挂载，Docker 就可以将一个宿主机上的目录或文件，不动声色地挂载到容器中。</p>
<p>容器的镜像操作，比如 docker commit，都是发生在宿主机空间的。而由于 Mount Namespace 的隔离作用，宿主机并不知道这个绑定挂载的存在。所以，在宿主机看来，容器中可读写层的 /test 目录（/var/lib/docker/aufs/mnt/[可读写层 ID]/test），始终是空的。所以容器 Volume 里的信息，并不会被 docker commit 提交掉；但这个挂载点目录 /test 本身，则会出现在新的镜像当中。</p>
<p>docker exec：i.e. spawn a new process in existing namespace。（在已经存在的命名空间生成一个新的进程） </p>
<p>所有的层都保存在diff目录下，包括可读写层修改的数据</p>
<h2 id="本章的主要问题（没答案）"><a href="#本章的主要问题（没答案）" class="headerlink" title="本章的主要问题（没答案）"></a>本章的主要问题（没答案）</h2><p><strong>从问题出发，根据问题理解答案</strong></p>
<p>一、docker镜像如何制作的两种方式是什么？<br>二、容器既然是一个封闭的进程，那么外接程序是如何进入容器这个进程的呢？<br>三、docker commit对挂载点volume内容修改的影响是什么？<br>四、容器与宿主机如何进行文件读写？或volume是为了解决什么题？<br>五、Docker的copyData功能是什么？解决了什么问题？<br>六、bind mount机制是什么？<br>七、cgroup Namespace的作用是什么？</p>
<h2 id="Linux-Namespace-工作原理"><a href="#Linux-Namespace-工作原理" class="headerlink" title="Linux Namespace 工作原理"></a>Linux Namespace 工作原理</h2><p><strong>模拟进去其他进程的网络空间理解Linux Namespace 工作原理</strong></p>
<p>通过操作系统进程相关的知识，逐步剖析 Docker 容器的方法，是理解容器的一个关键思路，希望你一定要掌握。</p>
<p>通过如下指令，你可以看到当前正在运行的 Docker 容器的进程号（PID）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@wang-18 ~]# docker inspect --format &#39;&#123;&#123; .State.Pid &#125;&#125;&#39; d45c14ee5303</span><br><span class="line">18814</span><br><span class="line">[root@wang-18 ~]# ls -l &#x2F;proc&#x2F;18814&#x2F;ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx. 1 root root 0 9月   3 18:57 ipc -&gt; ipc:[4026532561]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 9月   3 18:57 mnt -&gt; mnt:[4026532559]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 9月   2 18:24 net -&gt; net:[4026532564]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 9月   3 18:57 pid -&gt; pid:[4026532562]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 9月   5 17:11 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 9月   3 18:57 uts -&gt; uts:[4026532560]</span><br></pre></td></tr></table></figure>



<p>一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的，这正是 docker exec 的实现原理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@wang-18 test]# cat &lt;&lt; EOF &gt; set_ns.c</span><br><span class="line"></span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define errExit(msg) do &#123; perror(msg); exit(EXIT_FAILURE);&#125; while (0)</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    int fd;</span><br><span class="line">    </span><br><span class="line">    fd &#x3D; open(argv[1], O_RDONLY);</span><br><span class="line">    if (setns(fd, 0) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        errExit(&quot;setns&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    execvp(argv[2], &amp;argv[2]); </span><br><span class="line">    errExit(&quot;execvp&quot;);</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">[root@wang-18 test]# gcc -o set_ns set_ns.c </span><br><span class="line">[root@wang-18 test]# .&#x2F;set_ns &#x2F;proc&#x2F;18814&#x2F;ns&#x2F;net &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">[root@wang-18 test]# ifconfig</span><br><span class="line">eth0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.18.3  netmask 255.255.255.0  broadcast 172.16.18.255</span><br><span class="line">        ether 02:42:ac:10:12:03  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 8  bytes 656 (656.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>



<p>在 /proc/[PID]/ns/net 目录下，这个 PID=56900 进程，与我们前面的 Docker 容器进程（PID=18814）指向的 Network Namespace 文件完全一样。这说明这两个进程，共享了这个名叫 net:[4026532564]的 Network Namespace。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@wang-18 test]# ps -ef | grep &#x2F;bin&#x2F;bash | grep -v grep</span><br><span class="line">root      18814  18795  0 9月02 pts&#x2F;0   00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line">root      52675  18795  0 9月03 ?       00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line">root      56900  56736  0 17:19 pts&#x2F;0    00:00:00 &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">[root@wang-18 test]# ls -l &#x2F;proc&#x2F;18814&#x2F;ns&#x2F;net &#x2F;proc&#x2F;56900&#x2F;ns&#x2F;net</span><br><span class="line">lrwxrwxrwx. 1 root root 0 9月   2 18:24 &#x2F;proc&#x2F;18814&#x2F;ns&#x2F;net -&gt; net:[4026532564]</span><br><span class="line">lrwxrwxrwx. 1 root root 0 9月   5 17:21 &#x2F;proc&#x2F;56900&#x2F;ns&#x2F;net -&gt; net:[4026532564]</span><br></pre></td></tr></table></figure>



<h1 id="09-从容器到容器云：谈谈Kubernetes的本质"><a href="#09-从容器到容器云：谈谈Kubernetes的本质" class="headerlink" title="09 | 从容器到容器云：谈谈Kubernetes的本质"></a>09 | 从容器到容器云：谈谈Kubernetes的本质</h1><h2 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h2><p>“容器” 实际上是一个由 Linux Namespace、Linux Cgroups 和 rootfs 三种技术构建出来的进程的隔离环境。</p>
<p>一组联合挂载在 /var/lib/docker/aufs/mnt 上的 rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；</p>
<p>一个由 Namespace+Cgroups 构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。</p>
<p>首先，Kubernetes 项目要解决的问题是什么？编排, 调度, 容器云,  集群管理等等</p>
<h2 id="Kubernetes架构"><a href="#Kubernetes架构" class="headerlink" title="Kubernetes架构"></a>Kubernetes架构</h2><p>Kubernetes 项目的架构，由 Master控制节点 和 Node 计算节点两种节点组成。跟它的原型项目 Borg 类似。</p>
<p>Master  控制节点，由三个紧密协作的独立组件组合而成，它们分别是负责 API 服务的 kube-apiserver、负责调度的  kube-scheduler，以及负责容器编排的 kube-controller-manager。整个集群的持久化数据，则由  kube-apiserver 处理后保存在 Etcd 中。</p>
<p>Master 节点：编排、管理、调度用户提交的作业。</p>
<img src="/img/body/jike/8ee9f2fa987eccb490cfaa91c6484f67.png" alt="img" style="zoom:67%;max-width:70%" />



<p>  CNI（Container Networking Interface），CRI（Container Runtime  Interface），CSI（Container Storage Interface）, OCI (Open Container Initiative)</p>
<p>node 计算节点上最核心的部分 kubelet 主要负责同容器运行时（比如 Docker 项目）打交道。而这个交互所依赖的，是一个称作 CRI 的远程调用接口，这个接口定义了容器运行时的各项核心操作，比如：启动一个容器需要的所有参数。只要你的这个容器运行时能够运行标准的容器镜像，它就可以通过实现 CRI 接入到 Kubernetes 项目当中。</p>
<p>而具体的容器运行时，比如 Docker 项目，则一般通过 OCI 这个容器运行时规范同底层的 Linux 操作系统进行交互，即：把 CRI 请求翻译成对 Linux 操作系统的调用（操作 Linux Namespace 和 Cgroups 等）</p>
<p>kubelet 还通过 gRPC 协议同一个叫作 Device Plugin 的插件进行交互。这个插件，是 Kubernetes 项目用来管理 GPU 等宿主机物理设备的主要组件，也是基于  Kubernetes 项目进行机器学习训练、高性能作业支持等工作必须关注的功能。</p>
<p>kubelet  的另一个重要功能，则是调用网络插件和存储插件为容器配置网络和持久化存储。这两个插件与 kubelet 进行交互的接口，分别是  CNI 和 CSI 。</p>
<h2 id="Kubernetes设计思想"><a href="#Kubernetes设计思想" class="headerlink" title="Kubernetes设计思想"></a>Kubernetes设计思想</h2><p>Kubernetes 项目就没有像同时期的各种“容器云”项目那样，把 Docker 作为整个架构的核心，而仅仅把它作为最底层的一个容器运行时实现。</p>
<p>k8s着重解决的问题: 运行在大规模集群中的各种任务之间，实际上存在着各种各样的关系。这些关系的处理，才是作业编排和管理系统最困难的地方。</p>
<p>那些原先拥挤在同一个虚拟机里的各个应用、组件、守护进程，都可以被分别做成镜像，然后运行在一个个专属的容器中。它们之间互不干涉，拥有各自的资源配额，可以被调度在整个集群里的任何一台机器上。而这，正是一个 PaaS 系统最理想的工作状态，也是所谓“微服务”思想得以落地的先决条件。</p>
<p>Kubernetes 项目最主要的设计思想是，从更宏观的角度，以统一的方式来定义任务之间的各种关系，并且为将来支持更多种类的关系留有余地。</p>
<img src="/img/body/jike/16c095d6efb8d8c226ad9b098689f306.png" alt="img" style="zoom:67%;max-width: 70%" />



<p>按照这幅图的线索，我们从容器这个最基础的概念出发，首先遇到了容器间“紧密协作”关系的难题，于是就扩展到了 Pod；有了 Pod 之后，我们希望能一次启动多个应用的实例，这样就需要 Deployment 这个 Pod  的多实例管理器；而有了这样一组相同的 Pod 后，我们又需要通过一个固定的 IP 地址和端口以负载均衡的方式访问它，于是就有了 Service。</p>
<p>Service 服务: 作为 Pod 的代理入口（Portal），代替 Pod 对外暴露一个固定的网络地址。</p>
<h2 id="如何容器化应用"><a href="#如何容器化应用" class="headerlink" title="如何容器化应用"></a>如何容器化应用</h2><p>除了应用与应用之间的关系外，应用运行的形态是影响“如何容器化这个应用”的第二个重要因素。</p>
<p>在 Kubernetes 项目中，我们所推崇的使用方法是：</p>
<p>首先，通过一个“编排对象”，比如 Pod、Job、CronJob 等，来描述你试图管理的应用；</p>
<p>然后，再为它定义一些“服务对象”，比如 Service、Secret、Horizontal Pod Autoscaler（自动水平扩展器）等。这些对象，会负责具体的平台级功能。</p>
<p>这种使用方法，就是所谓的“声明式 API”。这种 API 对应的“编排对象”和“服务对象”，都是 Kubernetes 项目中的 API 对象（API Object）。</p>
<p>API（Application Programming Interface,应用程序编程接口）</p>
<h2 id="编排和调度区别"><a href="#编排和调度区别" class="headerlink" title="编排和调度区别"></a>编排和调度区别</h2><p>过去很多的集群管理项目（比如  Yarn、Mesos，以及 Swarm）所擅长的，都是把一个容器，按照某种规则，放置在某个最佳节点上运行起来。这种功能，我们称为“调度”。</p>
<p>而  Kubernetes  项目所擅长的，是按照用户的意愿和整个系统的规则，完全自动化地处理好容器之间的各种关系。这种功能，就是我们经常听到的一个概念：编排。</p>
<p>所以说，Kubernetes 项目的本质，是为用户提供一个具有普遍意义的容器编排工具。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">会跳的小蚂蚁</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://wang.ikongjian.com/2020/09/06/05-09-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8%E7%AF%87/">http://wang.ikongjian.com/2020/09/06/05-09-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://wang.ikongjian.com" target="_blank">蚂蚁博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kubernetes/">kubernetes</a><a class="post-meta__tags" href="/tags/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kuernetes/">深入剖析Kuernetes</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><div class="post-ad"><ins class="adsbygoogle" style="display:block" data-ad-format="fluid" data-ad-layout-key="xxxxxxxxxxxx" data-ad-client="ca-pub-xxxxxxxxxx" data-ad-slot="xxxxxxxxxx"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/09/07/nacos%E7%9A%84%E9%83%A8%E7%BD%B2%E5%92%8C%E4%BD%BF%E7%94%A8/"><img class="prev_cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">nacos的部署和使用</div></div></a></div><div class="next-post pull_right"><a href="/2020/09/01/00-04-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90k8s%E8%AF%BE%E5%89%8D%E5%BF%85%E8%AF%BB/"><img class="next_cover" src="/img/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">00-04.深入剖析k8s课前必读</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/09/01/00-04-深入剖析k8s课前必读/" title="00-04.深入剖析k8s课前必读"><img class="relatedPosts_cover" src="/img/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-01</div><div class="relatedPosts_title">00-04.深入剖析k8s课前必读</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/09/10-12-kubernetest集群搭建与实践/" title="10-12.Kubernetest集群搭建与实践"><img class="relatedPosts_cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-09</div><div class="relatedPosts_title">10-12.Kubernetest集群搭建与实践</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/11/13-15-深入解析pod对象/" title="13-15.深入解析pod对象"><img class="relatedPosts_cover" src="/img/gkihqEjXxJ5UZ1C.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-11</div><div class="relatedPosts_title">13-15.深入解析pod对象</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/24/28-31-kubernetes容器持久化存储/" title="28-31.Kubernetes容器持久化存储"><img class="relatedPosts_cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-24</div><div class="relatedPosts_title">28-31.Kubernetes容器持久化存储</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/18/18-20-深入理解statefulset/" title="18-20.深入理解StatefulSet"><img class="relatedPosts_cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-18</div><div class="relatedPosts_title">18-20.深入理解StatefulSet</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/16/16-17-控制器和deployment/" title="16-17.控制器和deployment"><img class="relatedPosts_cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-16</div><div class="relatedPosts_title">16-17.控制器和deployment</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: '3trHicwpGcV9ectvS8IUTPyA-gzGzoHsz',
  appKey: 'O89QU06amIo1zHhNLV9BMxU7',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 会跳的小蚂蚁</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.gov.cn/portal/index.do" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>京ICP备20023989号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script></body></html>